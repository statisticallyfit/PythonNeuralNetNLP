% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{fancyvrb,newverbs,xcolor} % for code highlighting
\usepackage[top=2cm, bottom=1.5cm, left=2cm, right=2cm]{geometry} % for page margins

\usepackage[english]{babel}
% Ana: adding graphics package for images
\usepackage{graphics}
\usepackage{graphicx}

% change background color for inline code in
% markdown files. The following code does not work well for
% long text as the text will exceed the page boundary
%\definecolor{bgcolor}{HTML}{E0E0E0}
%\let\oldtexttt\texttt

% \renewcommand{\texttt}[1]{
% \colorbox{bgcolor}{\oldtexttt{#1}}
% }


%% Setting pythong ??? -----------------------------------------------------
%default_block_language: "lexer"
%default_inline_language: "lexer"


%% color and other settings for hyperref package -----------------------------
\hypersetup{
    bookmarksopen=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=RoyalBlue,
}

% Font Setup  ---------------------------------------------------------
\usepackage{unicode-math} % load 'fontspec' automatically
\setmainfont{Crimson}
%\setmainfont{Libertinus Sans} 
%\setmainfont{Alegreya}
\setmathfont{TeX Gyre Schola Math}


% Code syntax highlighting ---------------------------------------------------

% OLD PART -----------------
%\usepackage{minted}
%\usemintedstyle{manni}
%\setmonofont{Inconsolata}
% ---------------------------


% Preliminary macro things for code (snatched from macros in REPORT):  ------
\newcommand\CodeFontSizeSmall{\fontsize{9pt}{9pt}\selectfont}

\definecolor{originalmannibg}{HTML}{f2f2ff}
\colorlet{BasePurple}{originalmannibg!90}
\newcommand{\lighten}[3]{% Reference Color, Percentage, New Color Name
    \colorlet{#3}{#1!#2!white}
}
\lighten{BasePurple}{50}{mannibg}

% Code things --------------------
\usepackage{minted}
\usepackage{verbatim}  % has commenting



\usemintedstyle{manni}

%\setmonofont{Inconsolata} % setting code font
\setmonofont{Fira Mono}

% General code environment, used like: \begin{code}{python} .... \end{code}
% NOTE: this is how to nest two environments together: 
\newenvironment{code}[2][]
 {\vspace{-3pt}%
 \VerbatimEnvironment
  \begin{adjustwidth}{30pt}{30pt}
  \begin{minted}[
    fontsize=\CodeFontSizeSmall,
    breaklines, mathescape,
    style=manni, bgcolor=mannibg,  #1]{#2}}
 {\end{minted}\end{adjustwidth} 
     \vspace{-10pt}
 }
 
% TODO: test if possible to do \renewenvironment to renew the minted environment and just include this logic below whenever calling \begin{minted}[]{python} ... 
 
% Python code environment, used like \begin{pythonCode} ... \end{pythonCode}
\newenvironment{pythonCode}
 {\vspace{-3pt}%
 \VerbatimEnvironment
  \begin{adjustwidth}{30pt}{30pt}
  \begin{minted}[
    fontsize=\CodeFontSizeSmall,
    breaklines, mathescape,
    style=manni, bgcolor=mannibg]{python}}
 {\end{minted}\end{adjustwidth} 
     \vspace{-10pt}
 }



% General code output environment
\newenvironment{outputCode}
 {\VerbatimEnvironment
  \begin{adjustwidth}{30pt}{30pt}
  \begin{minted}[
    fontsize=\CodeFontSizeSmall,
    breaklines]{text}}
 {\end{minted}\end{adjustwidth}}


% Creating inline code font (equivalent to backticks in jupyter notebooks)
% Must use like: \pythoninline{...text here ... }
\newmintinline{python}{python3, fontsize=\CodeFontSizeSmall, bgcolor=mannibg}

%\newenvironment{mintInline}[1][]{\mintinline{latex}{#1}}{}
%\DeclareTextFontCommand{\mint}{\mintInline}


\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\author{}
\date{}

\begin{document}

\mintinline[]{python}{python title="codecell" from sympy import Matrix, Symbol, derive_by_array, Lambda, Function, MatrixSymbol, Derivative, diff, symbols from sympy import var from sympy.abc import x, i, j, a, b}

```python title=``codecell'' def myvar(letter: str, i: int, j: int)
-\textgreater{} Symbol: letter\_ij =
Symbol('\{\}\_\{\}\{\}'.format(letter, i+1, j+1), is\_commutative=True)
return letter\_ij

n,m,p = 3,3,2

X = Matrix(n, m, lambda i,j : myvar(`x', i, j)); X

\begin{minted}[]{python}
```python title="codecell"
W = Matrix(m, p, lambda i,j : myvar('w', i, j)); W
\end{minted}

\mintinline[]{python}{python title="codecell" A = MatrixSymbol('X',3,3); Matrix(A) B = MatrixSymbol('W',3,2)}

```python title=``codecell''

\begin{minted}[]{python}
```python title="codecell"

\end{minted}

```python title=``codecell'' v = lambda a,b: a*b

vL = Lambda((a,b), a*b)

n = Function(`v') \#, Lambda((a,b), a*b))

vN = lambda mat1, mat2: Matrix(mat1.shape{[}0{]}, mat2.shape{[}1{]},
lambda i, j: Symbol(``n\_\{\}\{\}''.format(i+1, j+1))); vN

Nelem = vN(X, W); Nelem

\begin{minted}[]{python}

```python title="codecell"
n(X,W)
\end{minted}

\mintinline[]{python}{python title="codecell" n(A,B)}
\mintinline[]{python}{python title="codecell" n(X,W).replace(n, v) # replace works when v = python lambda}
\mintinline[]{python}{python title="codecell" n(X,W).subs({n: vL}) # subs works when v = sympy lambda}
\mintinline[]{python}{python title="codecell" n(X,W).replace(n, vL)}
\mintinline[]{python}{python title="codecell" n(X,W).subs({n: v})# subs() doesn't work when v is python lambda}

\mintinline[]{python}{python title="codecell" Matrix(n(A,B).subs({n: vL}))}

\mintinline[]{python}{python title="codecell" #N = v(X, W); N N = n(A,B); N}
\mintinline[]{python}{python title="codecell" N.replace(n, v)}
\mintinline[]{python}{python title="codecell" N.replace(n, v).subs({A: X, B:W}) # replacing ariable values after doing function doesn't make the function apply directly on the values (matrices), need to replace values before the function is replaced, so that the function can act on them while they are given/alive.}

\mintinline[]{python}{python title="codecell" N.subs({n: vL, A:X, B:W})}
\mintinline[]{python}{python title="codecell" Nspec = N.subs({A:X, B:W}).replace(n, v); Nspec}
```python title=``codecell''

\begin{minted}[]{python}
```python title="codecell"
N.diff(N)
\end{minted}

\mintinline[]{python}{python title="codecell" N.diff(X)} ```python
title=``codecell''

\begin{minted}[]{python}
```python title="codecell"



\end{minted}

```python title=``codecell'' \# way 2 of declaring S (better way) sigma
= Function(`sigma')

sigmaApply = Function(``sigma\_apply'') \#lambda matrix:
matrix.applyfunc(sigma)

sigmaApply\_ = lambda matrix: matrix.applyfunc(sigma)

sigmaApply(A)

\begin{minted}[]{python}
```python title="codecell"
sigmaApply(A).subs({A: X})
\end{minted}

\mintinline[]{python}{python title="codecell" sigmaApply_(A)}

\mintinline[]{python}{python title="codecell" sigmaApply(A).subs({A: X}).replace(sigmaApply, sigmaApply_) # NOTE: subs of functions doesn't work, replace actually evaluates the replaced function!}

\mintinline[]{python}{python title="codecell" S = sigmaApply(N); S}
\mintinline[]{python}{python title="codecell" Derivative(S, S)}
\mintinline[]{python}{python title="codecell" Derivative(S, S).doit()}
\mintinline[]{python}{python title="codecell" Derivative(S, n(A,B)).doit()}
```python title=``codecell'' \#lambd = Function(``lambda'') \#Lagain =
lambd(sigmaApply(n(A))); Lagain

\hypertarget{difflagain-a-never-execute}{%
\section{diff(Lagain, A) \# never
execute}\label{difflagain-a-never-execute}}

\hypertarget{section}{%
\section{}\label{section}}

\begin{minted}[]{python}


```python title="codecell"
S.replace(A,X).replace(B,W)
\end{minted}

\mintinline[]{python}{python title="codecell" S.replace(n, v)}
\mintinline[]{python}{python title="codecell" S.subs({A:X, B:W}).replace(n, v)}
\mintinline[]{python}{python title="codecell" Sspec = S.subs({A:X, B:W}).replace(n, v).replace(sigmaApply, sigmaApply_) Sspec}
\mintinline[]{python}{python title="codecell" S.replace(n, vN) #.replace(sigmaApply, sigmaApply_)}
\mintinline[]{python}{python title="codecell" Selem = S.replace(n, vN).replace(sigmaApply, sigmaApply_); Selem}

```python title=``codecell'' import itertools

elemToSpecD = dict(itertools.chain(*{[}{[}(Nelem{[}i, j{]}, Nspec{[}i,
j{]}) for j in range(2){]} for i in range(3){]}))

elemToSpec = list(elemToSpecD.items())

Matrix(elemToSpec)

\begin{minted}[]{python}
```python title="codecell"
elemToSpecFuncD = dict(itertools.chain(*[[(Nelem[i, j], Function("n_{}{}".format(i + 1, j + 1))(Nspec[i, j])) for j in range(2)] for i in range(3)]))

elemToSpecFunc = list(elemToSpecFuncD.items())

Matrix(elemToSpecFunc)
\end{minted}

```python title=``codecell'' elemToSpecFuncArgsD =
dict(itertools.chain(*{[}{[}(Nelem{[}i, j{]},
Function(``n\_\{\}\{\}''.format(i + 1, j + 1))(\emph{X,}W)) for j in
range(2){]} for i in range(3){]}))

elemToSpecFuncArgs = list(elemToSpecFuncArgsD.items())

Matrix(elemToSpecFuncArgs)

\begin{minted}[]{python}
```python title="codecell"
Selem
\end{minted}

\mintinline[]{python}{python title="codecell" Selem.subs(elemToSpecD)}
\mintinline[]{python}{python title="codecell" Selem[0,1].diff(Nelem[0,1])}
\mintinline[]{python}{python title="codecell" Selem[0,1].diff(Nelem[0,1]).subs({Nelem[0,1] : Nspec[0,1]}) #Selem[0,1].diff(Nelem[0,1]).subs(dict([{Nelem[0,1] : Nspec[0,1]}]))}

\mintinline[]{python}{python title="codecell" Selem[0,1].diff(Nelem[0,1]).subs({Nelem[0,1] : Nspec[0,1]}).subs({Nspec[0,1] : 23})}
\mintinline[]{python}{python title="codecell" Selem[0,1].diff(Nelem[0,1]).subs({Nelem[0,1] : Nspec[0,1]}).replace(sigma, lambda x: 8*x**3)}
\mintinline[]{python}{python title="codecell" Selem[0,1].diff(Nelem[0,1]).replace(sigma, lambda x: 8*x**3)}
\mintinline[]{python}{python title="codecell" Selem[0,1].diff(Nelem[0,1]).replace(sigma, lambda x: 8*x**3).doit()}
\mintinline[]{python}{python title="codecell" # ### GOT IT: can replace now with expression and do derivative with respect to that expression. Selem[0,1].diff(Nelem[0,1]).subs({Nelem[0,1] : Nspec[0,1]}).replace(sigma, lambda x: 8*x**3).doit()}
\mintinline[]{python}{python title="codecell" Selem[0,1].subs({Nelem[0,1] : Nspec[0,1]}).diff(X[0,1])#.subs({Nelem[0,1] : Nspec[0,1]})}
\mintinline[]{python}{python title="codecell" Selem}

\mintinline[]{python}{python title="codecell" nt = Nelem.subs(elemToSpecFunc); nt}
\mintinline[]{python}{python title="codecell" st = Selem.subs(elemToSpecFunc); st}
\mintinline[]{python}{python title="codecell" st.diff(nt)}
\mintinline[]{python}{python title="codecell" st[0,0].diff(st[0,0].args[0])}
\mintinline[]{python}{python title="codecell" st[0,0].diff(X[0,0])}
\mintinline[]{python}{python title="codecell" st[0,0].diff(st[1,0].args[0])}
\mintinline[]{python}{python title="codecell" Selem.diff(Nelem)}
\mintinline[]{python}{python title="codecell" Selem.diff(Nelem).subs(elemToSpecFunc)}
```python title=``codecell'' \# CAN even replace elements after have
done an operation on them!!! replacing n\_21 * 2 with the number 4.
Sspec.subs(\{Nspec{[}0, 0{]}: 3\}).replace(sigma, lambda x: 2 *
x).replace(Nspec{[}2, 1{]} * 2, 4)

\begin{minted}[]{python}

```python title="codecell"
lambd = Function("lambda")
lambd_ = lambda matrix : sum(matrix)


vN(X, W)
\end{minted}

\mintinline[]{python}{python title="codecell" vN(A, B)}
\mintinline[]{python}{python title="codecell" L = lambd(S); L}
\mintinline[]{python}{python title="codecell" Nelem}
\mintinline[]{python}{python title="codecell" L.replace(n, vN)}
\mintinline[]{python}{python title="codecell" L.replace(n, vN).replace(sigmaApply, sigmaApply_)}
\mintinline[]{python}{python title="codecell" L.replace(n, v)} ```python
title=``codecell''

L.replace(n, v).replace(sigmaApply, sigmaApply\_)

\begin{minted}[]{python}

```python title="codecell"
L.subs({A:X, B:W}).replace(n, vL).replace(sigmaApply, sigmaApply_)
\end{minted}

\mintinline[]{python}{python title="codecell" L.replace(n, vN)}

```python title=``codecell'' L.replace(n, vN).subs(\{A:X,
B:W\}).replace(sigmaApply, sigmaApply\_).replace(lambd, lambd\_)

\begin{minted}[]{python}

```python title="codecell"
from sympy import symbols, Derivative

x, y, r, t = symbols('x y r t') # r (radius), t (angle theta)
f, g, h = symbols('f g h', cls=Function)
h = g(f(x))

Derivative(h, f(x)).doit()
\end{minted}

\mintinline[]{python}{python title="codecell" # Never do this gives recursion ERROR (max depth exceeded) # h = g(f(A)) # Derivative(h, A).doit()}

```python title=``codecell''

\begin{minted}[]{python}


```python title="codecell"
from sympy.abc import a, b

Llower = lambd(sigmaApply(n(a, b)))
Llower
\end{minted}

\mintinline[]{python}{python title="codecell" Derivative(Llower, a).doit()}
```python title=``codecell''

\begin{minted}[]{python}

```python title="codecell"
# ### WAY 1: of substituting to differentiate with respect to expression:
n_ij = Function('n_ij')
n_ij(A,B) # (N[0,0]); n_ij
\end{minted}

\mintinline[]{python}{python title="codecell" n_ij(A,B).args}

```python title=``codecell'' \# sigma(n\_ij).diff(n\_ij).replace(n\_ij,
N{[}0,0{]}) \# ERROR cannot deriv wi.r.t to the expression w11*x11 +
\ldots{}

sigma(n\_ij(A,B)).diff(n\_ij(A,B))

\begin{minted}[]{python}
```python title="codecell"
sigma(n_ij(*X,*W)).diff(X[0,0])
\end{minted}

\mintinline[]{python}{python title="codecell" nab_ij = n_ij(A,B) sigma(nab_ij).diff(nab_ij)#.subs({nab_ij : Nspec[0, 0]})}
\mintinline[]{python}{python title="codecell" sigma(nab_ij).diff(nab_ij).subs({nab_ij : Nspec[2, 1]})}

\mintinline[]{python}{python title="codecell" sigma(nab_ij).diff(nab_ij).subs({nab_ij : Nspec[2,1]}).subs({X[2,1]:77777})}
\mintinline[]{python}{python title="codecell" sigma(nab_ij).diff(nab_ij).subs({nab_ij : 23}) # ERROR if using replace() since it says can't calc derivs w.r.t to the x_11*w_11 + ...}

\mintinline[]{python}{python title="codecell" sigma(nab_ij).diff(nab_ij).subs({nab_ij : Nspec[2,1]}).doit()}
\mintinline[]{python}{python title="codecell" sigma(nab_ij).subs({nab_ij : Nspec[2,1]})#.diff(X[2,1])}
\mintinline[]{python}{python title="codecell" # Substituting the value of the function n_ij first, and THEN differentiating with respect to something in that substitution. (X_21) sigma(nab_ij).subs({nab_ij : Nspec[2,1]}).diff(X[2,1])}

```python title=``codecell'' Selem{[}2,1{]}.subs(\{Nelem{[}2,1{]} :
Nspec{[}2,1{]}\}).diff(X{[}2,1{]})

\begin{minted}[]{python}

```python title="codecell"
# ### WAY 2:
n_11 = Function('n_11')(Nspec[0, 0]); n_11
\end{minted}

\mintinline[]{python}{python title="codecell" sigma(n_11)} ```python
title=``codecell'' assert Nspec{[}0,0{]} == n\_11.args{[}0{]}

sigma(n\_11).subs(\{n\_11 : n\_11.args{[}0{]}\})

\begin{minted}[]{python}
```python title="codecell"
sigma(n_11).diff(n_11) #.replace(n_ij, n_ij.args[0])
\end{minted}

\mintinline[]{python}{python title="codecell" sigma(n_11).diff(n_11).subs({n_11 : n_11.args[0]}).subs({X[0,0]:77777})}
\mintinline[]{python}{python title="codecell" sigma(n_11).diff(n_11).subs({n_11 : n_11.args[0]}).replace(n_11.args[0], 23) # same as subs in this case}

\mintinline[]{python}{python title="codecell" sigma(n_11).diff(X[0,0])}
```python title=``codecell'' id = Lambda(x, x)

sigma(n\_11).diff(X{[}0,0{]}).subs(\{n\_11 : id\})

\begin{minted}[]{python}

```python title="codecell"
# NOTE: so I don't think WAY 2 is correct because here it doesn't simplify the derivative d n11 / d eps11, since this should equal 1 because now n11 = eps11. Correct one is below (repeated from above)
sigma(n_11).diff(X[0,0]).subs({n_11 : Nspec[0,0]})
\end{minted}

\mintinline[]{python}{python title="codecell" # CORRECT WAY 1 sigma(n_11).subs({n_11 : Nspec[0,0]}).diff(X[0,0])}
```python title=``codecell'' \# CORRECT WAY 2

sigma(nab\_ij).subs(\{nab\_ij : Nspec{[}0,0{]}\}).diff(X{[}0,0{]})

\begin{minted}[]{python}
```python title="codecell"
# CORRECT WAY 3
Selem[2,1].subs({Nelem[2,1] : Nspec[2,1]}).diff(X[2,1])
\end{minted}

\mintinline[]{python}{python title="codecell" sigma(n_11) # WAY 1: sigma argument is already hardcoded}
\mintinline[]{python}{python title="codecell" sigma(nab_ij) # Way 2: sigma argument is function of matrixsymbol (better than 1)}
```python title=``codecell'' Selem{[}2,1{]} \# WAY 3: sigma argument is
just symbol and we replace it as function with argument hardcoded only
later. (better than 2)

\begin{minted}[]{python}

```python title="codecell"
L
\end{minted}

```python title=``codecell'' assert Selem == S.replace(n,
vN).replace(sigmaApply, sigmaApply\_)

Selem

\begin{minted}[]{python}

```python title="codecell"
L.replace(n, vN).replace(sigmaApply, sigmaApply_)
\end{minted}

\mintinline[]{python}{python title="codecell" #L.replace(n, vN).replace(sigmaApply, sigmaApply_).diff(Nelem[0,0])}

\mintinline[]{python}{python title="codecell" Lsum = L.replace(n, vN).replace(sigmaApply, sigmaApply_).replace(lambd, lambd_) Lsum}
\mintinline[]{python}{python title="codecell" Lsum.diff(Nelem)}
\mintinline[]{python}{python title="codecell" Lsum.subs(elemToSpec)#.diff(X[2,1])}
\mintinline[]{python}{python title="codecell" Lsum.subs(elemToSpec).diff(X)}
```python title=``codecell''

specToElemD = \{v : k for k, v in elemToSpecD.items()\}

Lsum.subs(elemToSpecD).diff(X).subs(specToElemD) ```

\end{document}
